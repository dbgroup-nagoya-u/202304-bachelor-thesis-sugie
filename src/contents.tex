% !TEX root = main.tex

\chapter{はじめに}

% 多次元索引の概要・有用性
多次元索引は複数の次元で表されたキーによる検索を補助するデータ構造である．
地理情報システムにおける空間オブジェクトの検索や，データベース管理システムにおける多次元データの選択演算効率化などに利用される．
多次元データは複数の次元から成るが，メモリやストレージ上では1次元空間上に配置されるため，多次元空間上での局所性を適切に反映した索引構造が求められる.

% 多次元索引の種類
多次元索引は多次元空間を直接扱うものと1次元空間へ射影して扱うものの大きく2つに分けられ，本稿では後者を主に扱う．
多次元空間を直接扱う索引の代表例はR木~\cite{sigmod:Beckmann1990}であり，多次元の最小包含矩形などを用いて多次元空間上の点を階層的にグループ化していく．
1次元空間へ射影するものは主に空間充填曲線に基づいており，Universal B木（UB木）~\cite{wwca:Bayer1997}が代表である．
後者の利点は，既存の効率的な1次元索引を流用でき，挿入・削除に伴う木の構造変更などが容易な点である．
一方で欠点として，多次元データを1次元化するため，隣接するデータが多次元空間上では近接していない可能性がある点が挙げられる．

% UARTの提案と問題点
本稿ではUB木およびAdaptive Radix Tree（ART）~\cite{icde:Leis2013}を組み合せた索引構造であるUniversal ART（UART）~\cite{deim:Suzuki2023}の改善について述べる．
UARTは汎用的に使用可能な多次元索引だが，データに偏りがある場合に挿入と範囲検索の性能が低下するという課題を持つ．
性能低下の原因は，不適切な空間分割による疎な部分空間の生成である．
UARTではノードの空きスペースがなくなった際に対応する多次元空間を分割することでノードを分割するが，分割後の部分空間が十分な数のレコードを持つという保証がない．
そのため挿入されるレコードに空間的な偏りがある際に，レコードを少数しか持たない疎なノードが多数生成され性能を低下させている．

% 本論文の目的と論文構成
本研究では分割後の各空間が十分な数のレコードを持つよう空間分割の手法を改善する．
まず，UARTの基となるARTとUB木の概要について述べ，続けてUARTの概要について述べる．
最後に，既存手法における空間分割の問題点と空間使用量に基づく空間分割の改善について説明し，論文全体のまとめを述べる．




\chapter{関連研究}

UARTの構成要素として利用するUB木とARTについて説明する．

\section{Universal B木（UB木）}

UB木~\cite{vldb:ramsak2000}は，多次元空間を\ZCurve に基づき1次元空間に変換し，変換後の\ZValue を\BTree のキーとして使用する索引構造である．
構造自体と，検索・挿入・削除といった各操作は\BTree と変わらない．
そのため，UB木の特徴である\ZCurve と\BTree について述べる．

\ZCurve ~\cite{acm:Gaede1998}は空間充填曲線の一種であり，2次元空間であれば``Z''の記号を描くような曲線となる．
\ZValue は\ZCurve 上の開始点からの距離であり，距離が近いものは多次元空間上でも近いことが多い．
ただし，空間充填曲線の性質上，\ZValue としては隣接するものが多次元空間上では遠く離れる場合もある．
\ZValue への変換は，多次元座標の各座標を2進符号化し上位ビットから順に交互配置することで行う．

\BTree ~\cite{book:Kitagawa1996}は，\Fig{\ref{fig:bptree}}に示すように索引部とデータ部からなるバランス木である．
索引部はレコードのキー値とデータ部へのポインタが格納された中間ノードの集まりである．
一方，データ部はキー値に対応するレコードと，隣の葉ノードをつなぐポインタが格納された葉ノードの集まりである．
そのため，木の高さが葉ノードの広がりに比べ低くなりノードアクセス数が減少する．

以上の構造から，\BTree は読み取り操作（点検索および範囲検索）・書き込み操作両面においてバランスの取れた性能を持つ．
索引部がレコードそのもではなくキー値のみになっていることから，点検索におけるキー値の比較や書き込み操作による索引部の変更が効率よく行える．
更に，葉ノードのポインタをたどることで全検索や範囲検索も高速に行うことができる．
また，各ノードはが全て同じサイズの領域として管理されるのでメモリ管理が容易となり利用効率も向上する．

\begin{figure}[tb]
  \centering
  \includegraphics{./figures/fig_bptree.pdf}
  \caption{\BTree の構造}
  \label{fig:bptree}
\end{figure}

UB木は\BTree の一種であるためそのデータ構造は効率的だが，空間分割が非効率的であるという問題がある．
UB木はノードの空き容量がなくなった際にノードを分割するが，分割点は分割後のサイズによって決定され，空間的な面は基本的に考慮されない．
つまり，多次元空間上で非連続な領域が同じノードに割り当てられる可能性があり，各ノードに対応する多次元包囲矩形が過剰に拡大しうる．

\section{Adaptive Radix Tree（ART）}

ART~\cite{icde:Leis2013}は基数木（Radix Tree）の拡張であり，レコード数に応じてノードサイズを動的に選択する索引構造である．
また，基数木はトライ木の空間利用効率を最適化した索引構造である．
そのため，本節ではトライ木と基数木の概要について述べてから，動的選択の概要について述べる．

トライ木は，文字列を表すための索引構造である．
根ノード以外のノード一つ一つが1文字を表し，文字の種類数だけ子ノードへのポインタを持つ．
文字列は，根ノードから葉ノードまでに通ったノードの順で文字をつないだものである．

トライ木は，文字列の検索速度に優れるが，空間利用効率が非常に大きい．
全ての子ノードが文字の種類数だけポインタを持つため，文字の種類数が多かったり，文字列が長かったりすると非常に大量のメモリを消費する．
加えて，ポインタの多くがヌルポインタとなり空間利用効率も悪い．
そこで，トライ木の空間利用効率を抑えた索引構造が基数木である．

基数木は，基本的にトライ木と同様の索引構造である．
基数木とトライ木の違いは，子ノードが一つしかないノードをひとまとめにすることである．
つまり，ある文字の後に続く文字が1種類しかない場合は，ノードに文字列を対応させる．
まとめた文字が多いほど，ノードの数が減り空間使用量を抑えられる．
しかし，まだ多くのノードがヌルポインタを持つため空間利用効率はよくない．
そこで，大量のヌルポインタを減らした索引構造がARTである．

ARTでは与えられたキーを1バイトの部分キーに分割し索引を構築するため，各ノードで最大256個のレコードを保持する．
そこで，ヌルポインタの数を減らすために，子ノードの数に応じて使用するノードを変える．
選択されるノードはNode4，Node16，Node48，Node256の4種類であり，それぞれ対応する数のレコードを格納できる．
各ノードは保持するレコードの数だけでなく，保持する方法も違う．

Node4は，キーと子ノードへのポインタを4個ずつ持つ．
キーとキーに対応する子ノードへのポインタは，どちらも$i$番目に保持される．
ここで，キーが保存される配列を$key\_array$，ポインタが保存される配列を$pointer\_array$とすると，
\[key\_array[i]=key\]
\[pointer\_array[i]=child\_pointer\]
が成立する．
つまり，$i$番目のキーはi番目のポインタに対応している．
Node16もキーとと子ノードへのポインタを持つ数が16になっただけで，Node4と同じ構造である．

Node48は，キーと子ノードへのポインタを48個ずつ持つ．
しかし，$key\_array$のサイズは256である．
そして，キーの値がキーが格納されているインデックスの値と一致し，キーの値と対応する子ノードへのポインタが格納されているインデックスの値と一致する．
つまり，
\[key\_array[key]=i\]
\[pointer\_array[i]=child\_pointer\]
が成立する．

Node256では，キーと子ノードへのポインタを256個ずつ持つ．
$key\_array$はなく，キーが$pointer\_array$のインデックスに一致する．
つまり，
\[pointer\_array[key]=child\_pointer\]
が成立する．

ARTは部分キーに偏りのある箇所では容量の少ないNode4やNode16が使用され，基数木の欠点である空間利用効率の悪化を克服している．
UARTでもキーの管理にノード選択を用いることで空間利用効率を向上させている．




\chapter{Universal Adaptive Radix Tree（UART）}

UARTはUB木を拡張し，主に空間分割を担うART層と挿入されたレコードの保持を担うUB層に分けた多次元索引である．
\ZCurve は多次元空間を1次元上の値として表現しており，上位ビットから下位ビットに進むにつれ粒度の細かい空間分割が行われる．
そこで，UARTでは変換後の\ZValue を1バイトずつの部分キーに区切り，部分キーによって表される空間分割をARTにより管理する．
つまり，ART層では多次元空間上でレコードが密な領域ほど空間が分割され，深い階層が生成される．
UB層は挿入されたレコードを保持するデータ層であり，該当領域に存在する疎なレコード群への効率的な範囲走査を実現する．

\Fig{\ref{fig:uart}}にUARTの概念図を示す．
本来のUARTでは\ZValue を1バイトずつに区切るが，\Fig{\ref{fig:uart}}では\ZValue を4ビットごとに区切っている．
また，ART層の丸はレコードを，UB層の丸はUB木のノードを表している．
そして，区切られた\ZValue のうち上位4ビットと中位4ビットは各層のグレー色で塗りつぶされた区画に，下位の4ビットは最下層にある灰色のレコードに対応している．
以下では，ART層とUB層の構造について概略を述べる．

\begin{figure}[tb]
  \centering
  \includegraphics[scale = 1.75]{./figures/fig_uart.pdf}
  \caption{UARTの構造}
  \label{fig:uart}
\end{figure}

\paragraph{ART層}

ART層は\ZValue をキーとしてARTに格納することで多次元空間を階層的に分割する索引層である．
ARTではキーを1バイトの部分キーに分割するため，各階層で空間は256分割される．
分割された空間のうちレコードが密に存在する箇所は後述する手続きによって下の階層が生成され，再帰的により細かい空間分割が行われる．
一方，ART中の各ノードはUB木の根ノード（i.e., UB層へのポインタ）をヘッダ領域に持ち，下の階層を持たない空間のレコードはそちらで保持される．

\paragraph{UB層}

UB層はART層の各階層各空間で保持されるUB木の集合であり，レコードの実体はこちらで管理される．
各UB木はその階層における\ZValue の部分キーを検索キー，挿入された空間オブジェクトとペイロードの組をレコードとして持つ．
なお最下層，つまり\ZValue の全長を用いた空間分割後のUB木は，部分キーとなる\ZValue を持たないため一般的な\BTree として生成される．
UB木の構築方法は既存のものと同様であり，\BTree に由来する効率的な範囲走査を可能とする．
ただし，既存研究において各UB木は根ノードのみしか持たない点に注意する~\cite{deim:Suzuki2023}．





\chapter{UARTにおける空間分割の効率化}

既存研究の課題として，オブジェクトが疎に分布する空間の管理が不十分であり，偏った分布における性能低下が挙げられる~\cite{deim:Suzuki2023}．
例えば全オブジェクトが1つの部分空間に偏る場合は，最下層までARTが展開され，\BTree によって全オブジェクトが管理されるため空間効率に関する問題は発生しない．
同様に，オブジェクトが空間全域で一様に分布する場合は，各部分空間に対応するUB木が一定数のオブジェクトを管理するためこちらも問題ない．
しかし，分布が適度に偏っているとき，既存のUARTでは少数のレコードしか持たないUB木が多数生成され性能が低下してしまう．

分布の偏りによる性能低下は，既存研究におけるUB木が根ノード1つしか持たず，オブジェクトが疎な空間のレコードを十分に保持できないためである．
既存研究ではUB木の根ノードを一種の書込み用バッファとして利用しており，空き容量がなくなった際は即座にオブジェクト数が最も多い部分空間を選びART層で下層を生成する．
この密な空間を選ぶという方針自体は誤っていないが，部分空間における空間使用量を考慮せず，単純にレコード数の多い空間を選ぶという手続きに問題がある．
つまり，各部分空間のオブジェクト数の差が少ない（i.e., 分布がロングテールを持つ）とき，この手続きではオブジェクト数が少ない部分空間においても下層が生成されてしまう．
現実的なワークロードやデータセットにおいてロングテールは頻出するため，この問題への対応は必須である．

オブジェクトが疎な空間において，不要な空間分割がUARTのボトルネックとなっている主な原因は2つある．
1つは，空間分割の操作はその他の操作に比べ処理時間が長くなることである．
空間分割はART層とUB層にまたがりどちらも構造を変化させる複雑な処理であるため，その他の処理よりも工程数が多くなる．
加えて，空間分割の回数が多いほど，データを削除したときに行われる空間併合の回数も増える．
空間併合も空間分割同様に，ART層とUB層にまたがった処理であるため処理時間が長くなる．
もう1つは，空間分割が必要以上になされると，葉ノードで行われるシーケンシャルスキャンが生かされないことである． %B木のところにシーケンシャルスキャンを加筆すべき？
空間の範囲検索では，大きく分けて2つの操作が行われる．
まずART層で，深さ優先探索により検索範囲の始点が含まれるノードを探索する．
次にUB層で，キーの値が検索範囲を超えるかUB木内のレコードを全て読み込むまでシーケンシャルスキャンを行う．
そして，UB層での検索が終わったらART層での深さ優先探索を再開する．
基本的に，ART層での深さ優先探索が少なく，UB層でのシーケンシャルスキャンが多いほど実行時間は短縮できる．
しかし，オブジェクトが疎な空間の階層が多いと，深さ優先探索が増えてシーケンシャルスキャンは少なくなり実行時間が長くなる．

以上を踏まえると，UARTの空間利用効率は木の高さが高くも低くもなく，葉ノードにレコードが詰まっていれば最適だと考えられる．
そこで本研究では，下層生成の条件として一定の空間使用量を持つことを使用し，UB層において根ノード単体ではなくUB木としてレコードを保持する．
UB木は\ZValue を使用した二次索引であり，同じ\ZValue を持つレコードは内部で転置リスト（posting list）として保持される．
既存研究では各転置リスト内のレコード数のみを見たが，本研究では転置リストのサイズも考慮し一定のサイズを超えるまで下層を生成しない．
つまり，ノードの空き容量がなく下層も生成しない場合はノードを分割し，UB木を拡張する．
以降では，より具体的に提案手法を説明する．

\section{改善前後における空間分割手続き}

空間分割はレコードの挿入操作時に起こるため，はじめに空間分割が起こる前までの手続きを説明する．
レコードを挿入するときは，まず主キーから\ZValue を計算してART層を深さ優先探索する．
\ZValue の接頭辞を上位バイトから確認し，接頭辞が一致するようART層のパスを通る．
プレフィックスが一致しなかったとき，最後にプレフィックスが一致した階層に対応するUB木へ移動する．
挿入対象のUB木を発見したら，挿入対象となるUBノードを探索する．
UBノードが見つかったらレコードを挿入すべき転置リストを探索する．
転置リストが見つかるか，あるいは新たに作る場合，ノードにレコードを挿入できる空き容量が存在するか計算する．
ここでノードに十分な空き容量がなかったとき，空間を分割する．
空間分割からは既存手法と提案手法で手順が異なるため別々に説明する．

既存手法では前述したとおり，空き容量が足りなくなった時点で，オブジェクト数が最も多い部分空間を選択してART層で下層を生成していた．
空き容量が足りないというのは，レコードを挿入するとページサイズを超えてしまうことである．
オブジェクト数が最も多い部分空間というのは，同一ノード内にある転置リストの中でレコード数が最大である転置リストを指す．
つまり，選択された転置リスト内のレコードを新しいUBノードにコピーし，新たに作ったARTの下層にUBノードのポインタを格納することで空間分割をしていた．

提案手法は空き容量を計算した後に，抽出対象の転置リストのサイズがページサイズのおおよそ3分の1を超えているか計算する．
超えている場合は既存手法と同様の手順で下層を生成する．
超えていない場合はUBノードを分割する．
これにより，生成された下層には一定以上のオブジェクトが必ず含まれるため，各ノードの空間利用効率およびそれに伴う範囲走査性能の向上が見込める．







\chapter{評価実験}

% 実験概要
本研究では，偏りなどデータのパラメータに対する頑健性と，実データを用いた有用性を評価する．
そのために，各データに対して読み込みと書き込みを行い，それぞれのスループットを測定する．
以下ではより詳細な実験方法について述べる．

%ワークロード
本実験では，頑健性・有用性のどちらの評価においても，挿入，削除，更新，範囲検索いずれかのみを含むワークロードを用いてスループットを測定する．
どの実験も全て単一スレッドで行い，命令を逐次的に発行する．
\Tab{\ref{tab:environment}}に本実験で使用する環境を示す．

\begin{table}[tb]
  \caption{実験用サーバの構成}
  \label{tab:environment}
  \centering
  \begin{tabular}{ll}
    \toprule
    Item     & Value                                              \\
    \cmidrule(r){1-1}
    \cmidrule(l){2-2}
    CPU      & Intel(R) Xeon(R) Gold 6262V (two sockets)          \\
    RAM      & DIMM DDR4 (Registered) 2933 MHz (16GB $\times$ 14) \\
    OS       & Ubuntu 20.04.6 LTS                                 \\
    Compiler & GNU C++ ver. 9.4.0                                 \\
    \bottomrule
  \end{tabular}
\end{table}

%データセット
有用性の評価には実データを，パラメータに対する頑健性の評価にはシミュレーションデータを用いる．
有用性の評価に用いる実データはOpenStreetMapより入手した日本のPoint of Interest（POI）に関するデータであり，約85万点の2次元座標（緯度経度）からなる．
\Fig{\ref{fig:japan}}
\begin{figure}[tb]
  \centering
  \includegraphics[scale=0.4]{./figures/japan-poi.png}
  \caption{日本データ}
  \label{fig:japan}
\end{figure}
実験では各座標を倍精度浮動小数点型で管理する。
頑健性の評価には，各次元の値がZipf関数に従うシミュレーションデータを用いる．
次元の数は可変であり，各次元の値は4バイトの非負整数型で表す．
Zipf関数は各次元の値がZipfの法則に従うように多次元値を生成する関数である．
Zipfの法則は，ある要素の出現頻度とその大きさに双曲線の関係が成り立つという経験則である．
そして，Zipfデータセットは各次元独立で近似的に\Eq{\ref{eq:zipf}}に示すZipf分布に従う\footnote{\footnotesize\url{https://github.com/dbgroup-nagoya-u/cpp-utility}}．
\begin{equation}
  \label{eq:zipf}
  f(k; \alpha, |W|) = \frac{1 / k^{\alpha}}{\sum_{n = 1}^{|W|} 1 / n^{\alpha}}
\end{equation}
\Eq{\ref{eq:zipf}}中の\alpha はスキューパラメータであり，$\alpha = 0$の時にZipfデータセットは一様分布となる．

%比較対象
比較対象として空間分割を改善する前のUARTに加え，同じく\ZCurve を用いるUB木と空間索引としてよく用いられる\RTree を使用する．
\RTree は空間利用効率が高く範囲検索に優れており，データの次元数に合わせてboostとlibspatialindexの2つの実装を用いる．
boostの実装が，libspatialindexの実装に比べ高速な一方で，4次元以上に対応していないためである．

\section{頑健性}

UARTの頑健性を評価するために，シミュレーションデータセットを用いて書き込みと読み込みの性能を測定する．
シミュレーションデータを用いることで様々な偏りをもったデータセットを再現する．
それにより，パラメータに対して安定した性能が測定できるかと，どのようなパラメータが性能に影響するかを考察する．

\subsection{ページサイズ}

UARTをチューニングするためのパラメータとして，UB木のノードを生成する際のページサイズがある．
ページサイズはレコードの容量として捉えられるため，挿入操作や範囲検索の結果を左右することが考えられる．
そこで，UARTとその他の索引構造との比較をする前に，UARTの改善後と改善前においてページサイズが各性能に与える影響を評価する．

2次元のシミュレーションデータを用いて，UARTの改善前後における挿入と範囲検索のスループットを測定した．
結果を\Fig{\ref{graph:ps-in}}\Fig{\ref{graph:ps-sc}}に示す．
\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-pagesize-insert.pdf}
    \caption{ページサイズ変化時の挿入}
    \label{graph:ps-in}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-pagesize-scan.pdf}
    \caption{ページサイズ変化時の範囲検索}
    \label{graph:ps-sc}
  \end{minipage}
\end{figure}
また，実験に用いたUARTのパラメータを\Tab{\ref{tab:pagesize}}に示す．
\begin{table}[tb]
  \caption{ページサイズの実験に用いたデータセットのパラメータ}
  \label{tab:pagesize}
  \centering \small
  \begin{tabular}{llrrrr}
    \toprule
    比較対象     & 操作     & 次元 & レコード数 & スキュー & 選択率 \\
    \cmidrule(lr){1-1}
    \cmidrule(lr){2-2}
    \cmidrule(lr){3-3}
    \cmidrule(lr){4-4}
    \cmidrule(lr){5-5}
    \cmidrule(lr){6-6}
    UART         & 挿入     & 2    & 1,000,000  & 0.3      & NONE   \\
    UART（改善） & 挿入     & 2    & 1,000,000  & 0.3      & NONE   \\
    UART         & 範囲検索 & 2    & 1,000,000  & 0.3      & 0.0001 \\
    UART（改善） & 範囲検索 & 2    & 1,000,000  & 0.3      & 0.0001 \\
    \bottomrule
  \end{tabular}
\end{table}
以降では，UARTの改善後をUART（改善），UARTの改善前をUARTと表記する．
UART（改善）は全てのページサイズにおいてUARTよりよい結果が得られた．
挿入では，UART（改善）はUARTの1.3倍から1.8倍ほどのスループットになった．
UART（改善）ではページサイズの影響が小さく，UARTではページサイズが大きくなるとスループットが小さくなった．
また範囲検索では，UART（改善）はUARTの1.5倍から1.9倍ほどのスループットになった．
挿入のときとは反対に，UART（改善）ではページサイズが大きくなるとスループットも大きくなり，UARTではページサイズの影響が小さかった．

UART（改善）が全ての項目でUARTを上回った理由は，空間利用効率が上昇したためだと考えられる．
UART（改善）はUARTに比べ空間を分割しないため，下層が比較的生成されない．
階層が低いと，各操作におけるページアクセス数が減少する．
そのため，挿入や範囲検索時にキーを見つける時間が減少し，性能が向上したと考えられる．

挿入において，UART（改善）ではページサイズの影響が小さかった．
その理由は，ページアクセス数の減少による時間短縮と挿入に伴う木構造の変化による時間延長がトレードオフであるためだと考えられる．
葉ノードにレコードが挿入できなくなった場合，ART層で下層を生成するかUB層でノードを分割する．
ページサイズが小さい場合，下層生成が多く発生し木は高くなる
その一方で，ノードの分割回数と1分割当たりにかかる時間は小さくなる．
ページサイズが大きい場合，下層生成が発生しなくなり木は低くなる．
その一方で，ノードの分割回数と1分割当たりにかかる時間は大きくなる．
つまり，空間利用効率を最適化すると，下層生成とノード分割にかかる時間の増減が打ち消しあうと考えられる．
また，UARTではページサイズが大きくなるとスループットが小さくなった．
その理由は，ページアクセス数の減少による時間短縮と挿入に伴う木構造の変更による時間延長がトレードオフでないためだと考えられる．
空間分割が非効率だと，ページサイズが大きくても木が低くならない．
そのため，ページアクセス数が増加し，更にノードの分割回数と1分割当たりにかかる時間が大きくなる．

範囲検索において，UART（改善）ではページサイズが大きいときにスループットが良くなった．
その理由は，空間利用効率が最適化されたことによりページアクセス数が減少したためだと考えられる．
一方でUARTではページサイズの影響が小さかった理由は，ページサイズを変えても木の高さはほとんど変わらないことが原因だと考えられる．
空間分割戦略が非効率だと必要以上に高い木となりページアクセス数が増えてしまう．
範囲検索では特にページアクセス数がボトルネックになるので木の高さが性能に強く影響すると考えられる．

以上から，UART（改善）はページサイズを大きくするとページアクセス数が減少し，読み込み性能が向上すると考えられる．
そのためこれ以降の実験では，UART（改善）とUARTのページサイズ数を8,192バイトに設定する．

\subsection{書き込み}

書き込みは挿入・削除・更新の3項目からなる．
その3項目それぞれにおいて，シミュレーションデータセットのレコード数，次元，スキューをそれぞれ変更して実験した．
以下では注目したパラメータごとに結果と考察を示す．

% まず，データ数を変化させて書き込みの性能を測定した．
% データ数以外のパラメータは\Tab{\ref{tab:rec}}の値を使った．
% 結果を\Fig{\ref{graph:rec-upd-2-0}}から\Fig{\ref{graph:rec-upd-8-0.5}}に示す．

\begin{table}[tb]
  \caption{書き込みの実験における各データセットのパラメータ}
  \label{tab:rec}
  \centering \small
  \begin{tabular}{llrr}
    \toprule
    図                              & 操作 & 次元 & スキュー \\
    \cmidrule(lr){1-1}
    \cmidrule(lr){2-2}
    \cmidrule(lr){3-3}
    \cmidrule(lr){4-4}
    \Fig{\ref{graph:rec-ins}}       & 挿入 & 2    & 0        \\
    \Fig{\ref{graph:rec-del}}       & 削除 & 2    & 0        \\
    \Fig{\ref{graph:rec-upd-2-0}}   & 更新 & 2    & 0        \\
    \Fig{\ref{graph:rec-upd-2-0.5}} & 更新 & 2    & 0.5      \\
    \Fig{\ref{graph:rec-upd-8-0}}   & 更新 & 8    & 0        \\
    \Fig{\ref{graph:rec-upd-8-0.5}} & 更新 & 8    & 0.5      \\
    \bottomrule
  \end{tabular}
\end{table}
\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-datasize-insert.pdf}
    \caption{レコード数変化時の挿入}
    \label{graph:rec-ins}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-datasize-delete.pdf}
    \caption{レコード数変化時の削除}
    \label{graph:rec-del}
  \end{minipage}
\end{figure}
\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-record-update-2-0.pdf}
    \caption{レコード数変化時の更新（次元：2，スキュー：0）}
    \label{graph:rec-upd-2-0}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-record-update-2-0.5.pdf}
    \caption{レコード数変化時の更新（次元：2，スキュー：0.5）}
    \label{graph:rec-upd-2-0.5}
  \end{minipage}
\end{figure}
\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-record-update-8-0.pdf}
    \caption{レコード数変化時の更新3}
    \label{graph:rec-upd-8-0}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-record-update-8-0.5.pdf}
    \caption{レコード数変化時の更新4}
    \label{graph:rec-upd-8-0.5}
  \end{minipage}
\end{figure}

\begin{figure}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-dimention-insert-0.pdf}
    \caption{次元変化時の挿入}
    \label{graph:}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-dimention-insert-0.5.pdf}
    \caption{次元変化時の挿入}
    \label{graph:paired}
  \end{minipage}
\end{figure}

\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-dimention-delete-0.pdf}
    \caption{データ数変化時の削除}
    \label{graph:grouped}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-dimention-delete-0.5.pdf}
    \caption{データ数変化時の削除}
    \label{graph:paired}
  \end{minipage}
\end{figure}

\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-dimention-update-0.pdf}
    \caption{次元変化時の更新1}
    \label{graph:grouped}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-dimention-update-0.5.pdf}
    \caption{次元変化時の更新2}
    \label{graph:paired}
  \end{minipage}
\end{figure}

\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-skew-insert-2.pdf}
    \caption{データ数変化時の挿入3}
    \label{graph:grouped}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-skew-insert-8.pdf}
    \caption{データ数変化時の削除4}
    \label{graph:paired}
  \end{minipage}
\end{figure}

\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-skew-delete-2.pdf}
    \caption{データ数変化時の挿入}
    \label{graph:grouped}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-skew-delete-8.pdf}
    \caption{データ数変化時の削除}
    \label{graph:paired}
  \end{minipage}
\end{figure}

\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-skew-update-2.pdf}
    \caption{データ数変化時の挿入}
    \label{graph:grouped}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-skew-update-8.pdf}
    \caption{データ数変化時の削除}
    \label{graph:paired}
  \end{minipage}
\end{figure}

\subsection{読み込み}

読み込み性能を測定するために各データセットに対して範囲検索をした．
書き込みのとき同様，シミュレーションデータセットのレコード数，次元，スキューをそれぞれ変更して実験した．
注目したパラメータ以外は\Tab{\ref{tab:scan}}に使った値をまとめた．
\begin{table}[tb]
  \caption{読み込みの実験における各データセットのパラメータ}
  \label{tab:scan}
  \centering \small
  \begin{tabular}{lrrrr}
    \toprule
    図                               & 次元 & レコード数 & スキュー & 選択率 \\
    \cmidrule(lr){1-1}
    \cmidrule(lr){2-2}
    \cmidrule(lr){3-3}
    \cmidrule(lr){4-4}
    \cmidrule(lr){5-5}
    \Fig{\ref{graph:dim-sc}}         & \-   & 1000000    & 0        & 0.001  \\
    \Fig{\ref{graph:rec-sc}}         & 2    & \-         & 0        & 0.001  \\
    \Fig{\ref{graph:skew-sc}}        & 2    & 1000000    & \-       & 0.001  \\
    \Fig{\ref{graph:selectivity-sc}} & 2    & 1000000    & 0        & \-     \\
    \bottomrule
  \end{tabular}
\end{table}

次元を変化させた結果を\Fig{\ref{graph:dim-sc}}に示す．
UART（改善）は次元が2から3へ変わるときに急激に性能が低下し，それ以降は次元が大きくなるほど性能が低下した．
次元が2のとき，UART（改善）はUARTに比べ約2.5倍，boostの\RTree に比べ約0.8倍の性能になった．


次元が大きくなるほど性能が低下するのは，次元の呪いに似た現象が起きているためだと考えられる．
次元の呪いとは，データが高次元になるとデータ群の特徴量を計算するのに必要なデータ数が指数関数的に増加する現象である．
データ分布が高次元になると外側に偏ることによって起こると知られている．
この実験ではデータ数を固定しているため，次元数が増えるほどデータ数が不足し偏った分布になる．
分布が偏りすぎるとオブジェクトが疎な空間が多くできてしまう．
そのため，4章で述べたような性能低下が起こると考えられる．

データ数を変化させた結果を\Fig{\ref{graph:rec-sc}}に示す．
UART（改善）はデータ数が小さいと各索引は同程度の性能となり，データ数が大きいほど性能は向上した．
データ数が100万のとき，UART（改善）はUARTに比べ約2.5倍，boostの\RTree に比べ約0.8倍の性能になった．

データ数が多いとスループットが大きくなるのは，UART（改善）はデータ数の増加に比べ，階層が増加しないからである．
ART層は1階層増えるたびに，最大で256個の部分空間ができる．
中間層が持てる下層のポインタは最大で256である．
そのため，UART（改善）は指数関数的にデータ層のノードが増える．
一方で，あるレベルまで下層が生成されると，それ以降では木が高くなることは．ほとんどない．
よって，データ数が大きくなるほど，葉ノードの数に対してページアクセス数が少なくって性能が向上する

スキューを変化させた結果を\Fig{\ref{graph:skew-sc}}に示す．
UART（改善）はスキューの値では性能がほとんど変わらなかった．

スキューはUART（改善）データ分布の偏りを決めるパラメータである．
そのため，UART（改善）は偏りに対して頑健性があると考えられる．
これは，空間分割が適切に行われているためだと考えられる．

選択率を変化させた結果を\Fig{\ref{graph:selectivity-sc}}に示す．
UART（改善）は選択率が大きいほど性能が向上した．
選択率が0.01のとき，UART（改善）はUARTに比べ約3倍，boostの\RTree に比べ約0.8倍の性能になった．

選択率が小さいほど性能が低下するのは，点検索に近づくためだと考えられる．
選択率はデータセット全体の最小包含矩形に対して範囲操作で使用する問合せ矩形が占める面積の割合である．
つまり，選択率が小さいと範囲検索の範囲も小さくなる．
検索範囲が小さくなるとART層の空間を分割したサイズよりも十分大きくならない．
つまり，検索範囲が分割された部分空間を包含することが少なくなるので，シーケンシャルスキャンが行えず検索性能が低下すると考えられる．



\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-scan-datasize.pdf}
    \caption{データ数変化時の範囲検索}
    \label{graph:rec-sc}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-scan-dimenntion.pdf}
    \caption{次元数変化時の範囲検索}
    \label{graph:dim-sc}
  \end{minipage}
\end{figure}
\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-scan-skew.pdf}
    \caption{スキュー変化時の範囲検索}
    \label{graph:skew-sc}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-scan-selectivity.pdf}
    \caption{選択率変化時の範囲検索}
    \label{graph:selectivity-sc}
  \end{minipage}
\end{figure}

\section{有用性}

UARTの有用性を評価するために，日本の地理データセットを用いて書き込みと読み込みの性能を測定する．
実際のデータを用いることで現実的な運用を再現する．
それにより，UARTがデータベースなどの索引として適切な性能を持つか考察する．

実験結果を\Fig{\ref{graph:japan-wr}}と\Fig{\ref{graph:japan-wr}}に示す．
\begin{figure}[tb]
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-japan-write.pdf}
    \caption{日本データにおける書き込み性能}
    \label{graph:japan-wr}
  \end{minipage}
  \begin{minipage}[c]{0.495\textwidth}
    \centering
    \includegraphics[scale=0.5]{./figures/graph-japan-read.pdf}
    \caption{日本データにおける読み込み性能}
    \label{graph:japan-sc}
  \end{minipage}
\end{figure}
更新では，UART（改善）はUART，UART，UB木で同程度の性能となった．
挿入と削除では，UART（改善）はUB木に比べ約0.8倍，UARTに比べ約1.1倍の性能となった．
また全ての書き込み操作において，UART（改善）はboostの\RTree を大きく上回った．
そして範囲検索では，UART（改善）はboostの\BTree に比べ約0.8倍，UARTに比べ1.4倍の性能となり，boostの\RTree を大きく上回った．
よって，UART（改善）は有用性が高い索引であると分かった．

UART（改善）は読み書き両方において，特化した索引に近い性能を持つことが分かった．
このような結果になったのは，索引層は空間の範囲検索に，データ層は書き込みに役割が分担されているためだと考えられる．
役割分担したことによって，読み込み性能と書き込み性能における負の相関が弱くなると考えられる．
読み込み性能は索引層の構造に，書き込み性能はデータ層の構造に依存する．
そのため，索引層とデータ層が連動する場合，どちらかの層が対応する性能に最適化されてしまうともう片方の層に対応する性能は最適化されない．
つまり，どちらかの層が変化したときにもう一方も大きく構造変更させる場合は，読み書きの性能がトレードオフとなる．
例えば，UB木ではデータ層の構造変化に伴って索引層も構造変化する．
データ層の並びが変わると，索引層が持つ1次元値のキーも変わるためである．
データ層はシーケンシャルスキャンができる構造により書き込みに最適化されている．
一方で，空間の情報を無視して多次元キーを1次元キーに変えてしてまうため，範囲検索時には断続的な検索が多くなり低性能となる．
このように索引層とデータ層が連動するため両性能に負の相関が発生する．
しかし，UARTは役割分担ができているため索引層とデータ層は連動しない．
特に，不要な空間分割の回数を減らすように改善したため，データ層の構造変更が頻繁に起こっても索引層は少ない構造変化で済むようになった．
そのため，UART（改善）は読み書き両方に最適化されたと考えられる．






\chapter{おわりに}

本研究では，UARTにおける空間分割の効率化によるメモリ利用効率の向上について提案した．
空間使用量を考慮していないという既存研究の課題について説明し，UARTにおける空間使用量を考慮した空間分割について述べた．
今後は提案手法の実装，および既存研究との比較による有効性の検証をする予定である．
